<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<button>按钮1</button>
<button>按钮2</button>
<button>按钮3</button>
<script>

  //第一种：Es5没有使用闭包（错误的输出)
  const btns=document.getElementsByTagName('button');
  // for(var i=0;i<btns.length;i++)
  // {
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }

  //因为var没有作用域，所以相当于是全局的且跟着循环i的值一直更新的，所以i最后是2:
  // var i=2;
  // {
  //   i=0
  //   btns[i].addEventListener('click',function (){
  //   console.log('第' + i + '个按钮被点击');
  //   })
  // }
  // {
  //   i=1
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }
  // {
  //   i=2
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }

  //第二种：Es5使用闭包。函数是有块级作用域，所以闭包函数里的i不会跟着外部的变化。闭包函数是立即执行。
  // for(var i=0;i<btns.length;i++)
  // {
  //   (function (i){
  //     btns[i].addEventListener('click',function (){
  //       console.log('第' + i + '个按钮被点击');
  //     })
  //   })(i)
  // }

  //第三种：ES6中的let
  for(let i=0;i<btns.length;i++)
  {
    btns[i].addEventListener('click',function (event){
      console.log('第' + i + '个按钮被点击');
    })
  }
  // let 是有自己的作用域，所以每一次循环i都保存当前块级中
  // {
  //   var i=0;
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }
  // {
  //   var i=1;
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }
  // {
  //   var i=2;
  //   btns[i].addEventListener('click',function (){
  //     console.log('第' + i + '个按钮被点击');
  //   })
  // }

</script>

</body>
</html>